# 数据结构
## 第一章 C++递归练习

**递归的本质是不断压栈和弹栈的过程,每次调用递归方法相当于压栈,而每当执行到方法的终点(return)相当于弹栈**

### Test1

**使用递归生成排列**

---

1. 定义函数perm()表示集合所有的排列方式,E表示集合,Ei表示除去第i个元素的集合,ei表示第i个元素,ei.perm(Ei)表示ei元素拼接到perm(Ei)的所有结果之前
如{a,b,c},e1.perm(Ei)表示[abc,acb]
2. 假设有个集合E,我们需要获取索引k至m的所有排列

根据需求我们需要获取集合的所有排列方式,可以理解为我们可以通过调整集合元素的顺序构造出集合所有的排列方式,顺序打印这个集合中需要的范围即可

首先确定该递归的结束条件,集合大小为1时输出该排列;

否则执行{遍历所有元素,执行ei.perm(Ei)}


> eg. {1,2,3}
> 
> 123,132,213,231,321,312
---

### Test2
**编写模板函数Input,要求用户输入一个非负数,验证这个数是否大于或等于0,如果不是提示非法,需要重新输入一个数在函数非成功退出之前,应给用户三次机会,如果输入成功,返回true并将输入的数作为引用参数返回,反之返回false**

### Test3
**测试数组a中的元素是否是按升序排列(即a[i]<=a[i+1],其中0<=i<n-1)是返回true,反之返回false**

### Test4


### Test5


### Test6


### Test7



 

